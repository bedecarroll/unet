//! Vulnerability scanning integration system
//!
//! This module provides comprehensive vulnerability scanning capabilities for the Î¼Net system,
//! integrating with various security scanning tools and maintaining audit trails of all scans.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::{
    collections::HashMap,
    net::{IpAddr, Ipv4Addr},
    path::PathBuf,
    process::Command,
    sync::Arc,
    time::Duration,
};
use tokio::{
    sync::{Mutex, RwLock},
    time::{interval, sleep},
};
use tracing::{debug, error, info, warn};
use uuid::Uuid;

use crate::security_audit::{RiskLevel, SecurityEvent, SecurityEventType, log_security_event};

/// Vulnerability scanner types
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
#[serde(rename_all = "snake_case")]
pub enum ScannerType {
    /// Network vulnerability scanner (Nmap with scripts)
    NetworkVulnerabilityScanner,
    /// Container image scanner
    ContainerImageScanner,
    /// Dependency vulnerability scanner
    DependencyScanner,
    /// Configuration security scanner
    ConfigurationScanner,
    /// OWASP ZAP web application scanner
    WebApplicationScanner,
    /// Custom security scanner
    CustomScanner(String),
}

/// Vulnerability severity levels
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[serde(rename_all = "lowercase")]
pub enum VulnerabilitySeverity {
    Info,
    Low,
    Medium,
    High,
    Critical,
}

impl From<VulnerabilitySeverity> for RiskLevel {
    fn from(severity: VulnerabilitySeverity) -> Self {
        match severity {
            VulnerabilitySeverity::Info => RiskLevel::Info,
            VulnerabilitySeverity::Low => RiskLevel::Low,
            VulnerabilitySeverity::Medium => RiskLevel::Medium,
            VulnerabilitySeverity::High => RiskLevel::High,
            VulnerabilitySeverity::Critical => RiskLevel::Critical,
        }
    }
}

/// Individual vulnerability finding
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerabilityFinding {
    /// Unique finding ID
    pub id: Uuid,
    /// Vulnerability title
    pub title: String,
    /// Detailed description
    pub description: String,
    /// Severity level
    pub severity: VulnerabilitySeverity,
    /// CVE identifier if available
    pub cve_id: Option<String>,
    /// CVSS score if available
    pub cvss_score: Option<f32>,
    /// Affected component or service
    pub affected_component: String,
    /// Remediation recommendations
    pub remediation: Option<String>,
    /// References and links
    pub references: Vec<String>,
    /// Scanner-specific metadata
    pub metadata: HashMap<String, serde_json::Value>,
    /// Timestamp when vulnerability was first detected
    pub first_detected: DateTime<Utc>,
    /// Timestamp of last detection
    pub last_detected: DateTime<Utc>,
    /// Whether this finding has been acknowledged
    pub acknowledged: bool,
    /// Whether this finding has been resolved
    pub resolved: bool,
    /// Resolution timestamp
    pub resolved_at: Option<DateTime<Utc>>,
}

impl VulnerabilityFinding {
    /// Create a new vulnerability finding
    pub fn new(
        title: String,
        description: String,
        severity: VulnerabilitySeverity,
        affected_component: String,
    ) -> Self {
        let now = Utc::now();
        Self {
            id: Uuid::new_v4(),
            title,
            description,
            severity,
            cve_id: None,
            cvss_score: None,
            affected_component,
            remediation: None,
            references: Vec::new(),
            metadata: HashMap::new(),
            first_detected: now,
            last_detected: now,
            acknowledged: false,
            resolved: false,
            resolved_at: None,
        }
    }

    /// Mark finding as acknowledged
    pub fn acknowledge(&mut self) {
        self.acknowledged = true;
    }

    /// Mark finding as resolved
    pub fn resolve(&mut self) {
        self.resolved = true;
        self.resolved_at = Some(Utc::now());
    }

    /// Update last detected timestamp
    pub fn update_detected(&mut self) {
        self.last_detected = Utc::now();
    }
}

/// Vulnerability scan configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScanConfig {
    /// Scanner type
    pub scanner_type: ScannerType,
    /// Enable this scanner
    pub enabled: bool,
    /// Scan targets (IPs, hostnames, etc.)
    pub targets: Vec<String>,
    /// Scan frequency in minutes
    pub frequency_minutes: u64,
    /// Scanner-specific configuration
    pub scanner_config: HashMap<String, serde_json::Value>,
    /// Maximum scan duration in minutes
    pub timeout_minutes: u64,
    /// Minimum severity to report
    pub min_severity: VulnerabilitySeverity,
}

impl Default for ScanConfig {
    fn default() -> Self {
        Self {
            scanner_type: ScannerType::NetworkVulnerabilityScanner,
            enabled: false,
            targets: vec!["127.0.0.1".to_string()],
            frequency_minutes: 60,
            scanner_config: HashMap::new(),
            timeout_minutes: 30,
            min_severity: VulnerabilitySeverity::Medium,
        }
    }
}

/// Vulnerability scan result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScanResult {
    /// Unique scan ID
    pub scan_id: Uuid,
    /// Scanner type used
    pub scanner_type: ScannerType,
    /// Scan start time
    pub start_time: DateTime<Utc>,
    /// Scan end time
    pub end_time: Option<DateTime<Utc>>,
    /// Scan status
    pub status: ScanStatus,
    /// Targets scanned
    pub targets: Vec<String>,
    /// Vulnerabilities found
    pub findings: Vec<VulnerabilityFinding>,
    /// Scan statistics
    pub statistics: ScanStatistics,
    /// Error message if scan failed
    pub error_message: Option<String>,
    /// Scanner output logs
    pub scanner_output: Option<String>,
}

/// Scan execution status
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum ScanStatus {
    Pending,
    Running,
    Completed,
    Failed,
    Cancelled,
    TimedOut,
}

/// Scan statistics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScanStatistics {
    /// Total targets scanned
    pub targets_scanned: usize,
    /// Total vulnerabilities found
    pub total_vulnerabilities: usize,
    /// Vulnerabilities by severity
    pub vulnerabilities_by_severity: HashMap<VulnerabilitySeverity, usize>,
    /// Scan duration in seconds
    pub duration_seconds: u64,
    /// Scanner performance metrics
    pub performance_metrics: HashMap<String, f64>,
}

impl Default for ScanStatistics {
    fn default() -> Self {
        Self {
            targets_scanned: 0,
            total_vulnerabilities: 0,
            vulnerabilities_by_severity: HashMap::new(),
            duration_seconds: 0,
            performance_metrics: HashMap::new(),
        }
    }
}

/// Vulnerability scanner trait
pub trait VulnerabilityScanner: Send + Sync + std::fmt::Debug {
    /// Get scanner type
    fn scanner_type(&self) -> ScannerType;

    /// Execute a vulnerability scan
    async fn scan(
        &self,
        config: &ScanConfig,
        targets: &[String],
    ) -> Result<ScanResult, ScannerError>;

    /// Check if scanner is available and configured
    fn is_available(&self) -> bool;

    /// Get scanner-specific configuration schema
    fn get_config_schema(&self) -> serde_json::Value;

    /// Validate scanner configuration
    fn validate_config(
        &self,
        config: &HashMap<String, serde_json::Value>,
    ) -> Result<(), ScannerError>;
}

/// Network vulnerability scanner implementation
#[derive(Debug)]
pub struct NetworkVulnerabilityScanner {
    nmap_path: PathBuf,
}

impl NetworkVulnerabilityScanner {
    pub fn new() -> Self {
        Self {
            nmap_path: PathBuf::from("nmap"),
        }
    }

    pub fn with_nmap_path(mut self, path: PathBuf) -> Self {
        self.nmap_path = path;
        self
    }

    async fn execute_nmap_scan(&self, targets: &[String]) -> Result<String, ScannerError> {
        let mut cmd = Command::new(&self.nmap_path);
        cmd.args([
            "-sV", // Version detection
            "-sC", // Default scripts
            "--script",
            "vuln", // Vulnerability scripts
            "-T4",  // Timing template
            "--host-timeout",
            "10m",
        ]);

        for target in targets {
            cmd.arg(target);
        }

        let output = cmd
            .output()
            .map_err(|e| ScannerError::ExecutionError(format!("Failed to execute nmap: {}", e)))?;

        if !output.status.success() {
            return Err(ScannerError::ExecutionError(format!(
                "Nmap scan failed: {}",
                String::from_utf8_lossy(&output.stderr)
            )));
        }

        Ok(String::from_utf8_lossy(&output.stdout).to_string())
    }

    fn parse_nmap_output(&self, output: &str) -> Vec<VulnerabilityFinding> {
        // In a real implementation, this would parse nmap XML output
        // For now, we'll create a simple parser for demonstration
        let mut findings = Vec::new();

        if output.contains("CVE-") {
            findings.push(VulnerabilityFinding::new(
                "Example Network Vulnerability".to_string(),
                "This is a demonstration vulnerability finding from network scan".to_string(),
                VulnerabilitySeverity::Medium,
                "Network Service".to_string(),
            ));
        }

        findings
    }
}

impl VulnerabilityScanner for NetworkVulnerabilityScanner {
    fn scanner_type(&self) -> ScannerType {
        ScannerType::NetworkVulnerabilityScanner
    }

    async fn scan(
        &self,
        config: &ScanConfig,
        targets: &[String],
    ) -> Result<ScanResult, ScannerError> {
        let scan_id = Uuid::new_v4();
        let start_time = Utc::now();

        debug!(
            "Starting network vulnerability scan {} for targets: {:?}",
            scan_id, targets
        );

        let output = self.execute_nmap_scan(targets).await?;
        let findings = self.parse_nmap_output(&output);

        let end_time = Utc::now();
        let duration = (end_time - start_time).num_seconds() as u64;

        let mut vulnerabilities_by_severity = HashMap::new();
        for finding in &findings {
            *vulnerabilities_by_severity
                .entry(finding.severity.clone())
                .or_insert(0) += 1;
        }

        let statistics = ScanStatistics {
            targets_scanned: targets.len(),
            total_vulnerabilities: findings.len(),
            vulnerabilities_by_severity,
            duration_seconds: duration,
            performance_metrics: HashMap::new(),
        };

        Ok(ScanResult {
            scan_id,
            scanner_type: self.scanner_type(),
            start_time,
            end_time: Some(end_time),
            status: ScanStatus::Completed,
            targets: targets.to_vec(),
            findings,
            statistics,
            error_message: None,
            scanner_output: Some(output),
        })
    }

    fn is_available(&self) -> bool {
        Command::new(&self.nmap_path)
            .arg("--version")
            .output()
            .map(|output| output.status.success())
            .unwrap_or(false)
    }

    fn get_config_schema(&self) -> serde_json::Value {
        serde_json::json!({
            "type": "object",
            "properties": {
                "nmap_path": {
                    "type": "string",
                    "description": "Path to nmap executable"
                },
                "timing_template": {
                    "type": "string",
                    "enum": ["T0", "T1", "T2", "T3", "T4", "T5"],
                    "default": "T4"
                },
                "scripts": {
                    "type": "array",
                    "items": {"type": "string"},
                    "default": ["vuln"]
                }
            }
        })
    }

    fn validate_config(
        &self,
        _config: &HashMap<String, serde_json::Value>,
    ) -> Result<(), ScannerError> {
        // Validate nmap-specific configuration
        Ok(())
    }
}

/// Dependency vulnerability scanner
#[derive(Debug)]
pub struct DependencyScanner {
    cargo_audit_path: PathBuf,
}

impl DependencyScanner {
    pub fn new() -> Self {
        Self {
            cargo_audit_path: PathBuf::from("cargo-audit"),
        }
    }
}

impl VulnerabilityScanner for DependencyScanner {
    fn scanner_type(&self) -> ScannerType {
        ScannerType::DependencyScanner
    }

    async fn scan(
        &self,
        _config: &ScanConfig,
        _targets: &[String],
    ) -> Result<ScanResult, ScannerError> {
        let scan_id = Uuid::new_v4();
        let start_time = Utc::now();

        debug!("Starting dependency vulnerability scan {}", scan_id);

        // Execute cargo audit scan
        let output = Command::new(&self.cargo_audit_path)
            .args(["audit", "--format", "json"])
            .output()
            .map_err(|e| {
                ScannerError::ExecutionError(format!("Failed to execute cargo-audit: {}", e))
            })?;

        let findings = if output.status.success() {
            // Parse cargo audit JSON output
            // For demonstration, we'll create a simple finding
            vec![VulnerabilityFinding::new(
                "Example Dependency Vulnerability".to_string(),
                "This is a demonstration dependency vulnerability".to_string(),
                VulnerabilitySeverity::High,
                "Rust Dependency".to_string(),
            )]
        } else {
            Vec::new()
        };

        let end_time = Utc::now();
        let duration = (end_time - start_time).num_seconds() as u64;

        let total_vulnerabilities = findings.len();

        Ok(ScanResult {
            scan_id,
            scanner_type: self.scanner_type(),
            start_time,
            end_time: Some(end_time),
            status: ScanStatus::Completed,
            targets: vec!["Cargo.toml".to_string()],
            findings,
            statistics: ScanStatistics {
                targets_scanned: 1,
                total_vulnerabilities,
                vulnerabilities_by_severity: HashMap::new(),
                duration_seconds: duration,
                performance_metrics: HashMap::new(),
            },
            error_message: None,
            scanner_output: Some(String::from_utf8_lossy(&output.stdout).to_string()),
        })
    }

    fn is_available(&self) -> bool {
        Command::new(&self.cargo_audit_path)
            .arg("--version")
            .output()
            .map(|output| output.status.success())
            .unwrap_or(false)
    }

    fn get_config_schema(&self) -> serde_json::Value {
        serde_json::json!({
            "type": "object",
            "properties": {
                "cargo_audit_path": {
                    "type": "string",
                    "description": "Path to cargo-audit executable"
                }
            }
        })
    }

    fn validate_config(
        &self,
        _config: &HashMap<String, serde_json::Value>,
    ) -> Result<(), ScannerError> {
        Ok(())
    }
}

/// Vulnerability scanner manager
#[derive(Debug)]
pub struct VulnerabilityScannerManager {
    available_scanners: HashMap<ScannerType, bool>,
    scan_configs: Arc<RwLock<HashMap<ScannerType, ScanConfig>>>,
    scan_results: Arc<RwLock<Vec<ScanResult>>>,
    active_scans: Arc<Mutex<HashMap<Uuid, ScanStatus>>>,
    config: VulnerabilityScannerConfig,
}

/// Vulnerability scanner configuration
#[derive(Debug, Clone)]
pub struct VulnerabilityScannerConfig {
    /// Enable vulnerability scanning
    pub enabled: bool,
    /// Maximum concurrent scans
    pub max_concurrent_scans: usize,
    /// Scan result retention period in days
    pub result_retention_days: u32,
    /// Enable automatic remediation suggestions
    pub enable_auto_remediation: bool,
    /// Alert thresholds
    pub alert_thresholds: AlertThresholds,
}

#[derive(Debug, Clone)]
pub struct AlertThresholds {
    /// Alert on critical vulnerabilities
    pub critical_vulnerabilities: bool,
    /// Alert on high severity vulnerabilities
    pub high_severity_vulnerabilities: bool,
    /// Alert when vulnerability count exceeds threshold
    pub max_vulnerabilities_threshold: usize,
}

impl Default for VulnerabilityScannerConfig {
    fn default() -> Self {
        Self {
            enabled: true,
            max_concurrent_scans: 3,
            result_retention_days: 30,
            enable_auto_remediation: false,
            alert_thresholds: AlertThresholds {
                critical_vulnerabilities: true,
                high_severity_vulnerabilities: true,
                max_vulnerabilities_threshold: 50,
            },
        }
    }
}

/// Scanner error types
#[derive(Debug, thiserror::Error)]
pub enum ScannerError {
    #[error("Scanner not found: {0}")]
    ScannerNotFound(String),
    #[error("Scanner not available: {0}")]
    ScannerNotAvailable(String),
    #[error("Configuration error: {0}")]
    ConfigurationError(String),
    #[error("Execution error: {0}")]
    ExecutionError(String),
    #[error("Parse error: {0}")]
    ParseError(String),
    #[error("Timeout error: scan exceeded maximum duration")]
    TimeoutError,
    #[error("IO error: {0}")]
    IoError(#[from] std::io::Error),
}

impl VulnerabilityScannerManager {
    /// Create a new vulnerability scanner manager
    pub fn new(config: VulnerabilityScannerConfig) -> Self {
        let mut available_scanners: HashMap<ScannerType, bool> = HashMap::new();

        // Check scanner availability
        let network_scanner = NetworkVulnerabilityScanner::new();
        available_scanners.insert(
            ScannerType::NetworkVulnerabilityScanner,
            network_scanner.is_available(),
        );

        let dependency_scanner = DependencyScanner::new();
        available_scanners.insert(
            ScannerType::DependencyScanner,
            dependency_scanner.is_available(),
        );

        Self {
            available_scanners,
            scan_configs: Arc::new(RwLock::new(HashMap::new())),
            scan_results: Arc::new(RwLock::new(Vec::new())),
            active_scans: Arc::new(Mutex::new(HashMap::new())),
            config,
        }
    }

    /// Configure a scanner
    pub async fn configure_scanner(
        &self,
        scanner_type: ScannerType,
        config: ScanConfig,
    ) -> Result<(), ScannerError> {
        if self.available_scanners.contains_key(&scanner_type) {
            // Basic validation - in a real implementation, this would validate scanner-specific config
            if config.targets.is_empty() {
                return Err(ScannerError::ConfigurationError(
                    "At least one target must be specified".to_string(),
                ));
            }
            self.scan_configs.write().await.insert(scanner_type, config);
            Ok(())
        } else {
            Err(ScannerError::ScannerNotFound(format!("{:?}", scanner_type)))
        }
    }

    /// Execute a vulnerability scan
    pub async fn execute_scan(&self, scanner_type: ScannerType) -> Result<Uuid, ScannerError> {
        if !self.config.enabled {
            return Err(ScannerError::ConfigurationError(
                "Vulnerability scanning is disabled".to_string(),
            ));
        }

        let is_available = self
            .available_scanners
            .get(&scanner_type)
            .copied()
            .unwrap_or(false);
        if !is_available {
            return Err(ScannerError::ScannerNotAvailable(format!(
                "{:?} scanner is not available",
                scanner_type
            )));
        }

        let config = self
            .scan_configs
            .read()
            .await
            .get(&scanner_type)
            .cloned()
            .unwrap_or_default();

        if !config.enabled {
            return Err(ScannerError::ConfigurationError(format!(
                "{:?} scanner is disabled",
                scanner_type
            )));
        }

        // Check concurrent scan limit
        let active_count = self.active_scans.lock().await.len();
        if active_count >= self.config.max_concurrent_scans {
            return Err(ScannerError::ConfigurationError(
                "Maximum concurrent scans exceeded".to_string(),
            ));
        }

        let scan_id = Uuid::new_v4();

        // Mark scan as running
        self.active_scans
            .lock()
            .await
            .insert(scan_id, ScanStatus::Running);

        // Log security event
        log_security_event(
            SecurityEvent::new(
                SecurityEventType::SecurityScanDetected,
                format!("Started {} scan", scanner_type.as_ref()),
            )
            .with_metadata(
                "scan_id".to_string(),
                serde_json::Value::String(scan_id.to_string()),
            )
            .with_metadata(
                "scanner_type".to_string(),
                serde_json::Value::String(scanner_type.as_ref().to_string()),
            )
            .with_risk_level(RiskLevel::Info),
        )
        .await;

        // Execute scan in background (simplified for demonstration)
        let config_clone = config.clone();
        let scanner_type_clone = scanner_type.clone();
        let active_scans_clone = self.active_scans.clone();
        let scan_results_clone = self.scan_results.clone();
        let scanner_config = self.config.clone();

        tokio::spawn(async move {
            // Create a simplified demonstration scan result
            let mut scan_result = ScanResult {
                scan_id,
                scanner_type: scanner_type_clone,
                start_time: chrono::Utc::now(),
                end_time: Some(chrono::Utc::now()),
                status: ScanStatus::Completed,
                targets: config_clone.targets.clone(),
                findings: Vec::new(), // No findings for demonstration
                statistics: ScanStatistics::default(),
                error_message: None,
                scanner_output: Some("Demonstration scan completed successfully".to_string()),
            };

            // Check for alerts
            Self::check_scan_alerts(&scan_result, &scanner_config).await;

            // Store result
            scan_results_clone.write().await.push(scan_result);
            active_scans_clone.lock().await.remove(&scan_id);

            info!("Vulnerability scan {} completed successfully", scan_id);
        });

        Ok(scan_id)
    }

    /// Check scan results for alert conditions
    async fn check_scan_alerts(scan_result: &ScanResult, config: &VulnerabilityScannerConfig) {
        let critical_count = scan_result
            .findings
            .iter()
            .filter(|f| f.severity == VulnerabilitySeverity::Critical)
            .count();

        let high_count = scan_result
            .findings
            .iter()
            .filter(|f| f.severity == VulnerabilitySeverity::High)
            .count();

        // Alert on critical vulnerabilities
        if config.alert_thresholds.critical_vulnerabilities && critical_count > 0 {
            log_security_event(
                SecurityEvent::new(
                    SecurityEventType::SecurityScanDetected,
                    format!(
                        "Critical vulnerabilities detected: {} findings",
                        critical_count
                    ),
                )
                .with_metadata(
                    "scan_id".to_string(),
                    serde_json::Value::String(scan_result.scan_id.to_string()),
                )
                .with_metadata(
                    "critical_count".to_string(),
                    serde_json::Value::Number(critical_count.into()),
                )
                .with_risk_level(RiskLevel::Critical)
                .requires_investigation(),
            )
            .await;
        }

        // Alert on high severity vulnerabilities
        if config.alert_thresholds.high_severity_vulnerabilities && high_count > 0 {
            log_security_event(
                SecurityEvent::new(
                    SecurityEventType::SecurityScanDetected,
                    format!(
                        "High severity vulnerabilities detected: {} findings",
                        high_count
                    ),
                )
                .with_metadata(
                    "scan_id".to_string(),
                    serde_json::Value::String(scan_result.scan_id.to_string()),
                )
                .with_metadata(
                    "high_count".to_string(),
                    serde_json::Value::Number(high_count.into()),
                )
                .with_risk_level(RiskLevel::High),
            )
            .await;
        }

        // Alert on vulnerability count threshold
        if scan_result.findings.len() > config.alert_thresholds.max_vulnerabilities_threshold {
            log_security_event(
                SecurityEvent::new(
                    SecurityEventType::SecurityScanDetected,
                    format!(
                        "Vulnerability threshold exceeded: {} findings (threshold: {})",
                        scan_result.findings.len(),
                        config.alert_thresholds.max_vulnerabilities_threshold
                    ),
                )
                .with_metadata(
                    "scan_id".to_string(),
                    serde_json::Value::String(scan_result.scan_id.to_string()),
                )
                .with_metadata(
                    "finding_count".to_string(),
                    serde_json::Value::Number(scan_result.findings.len().into()),
                )
                .with_metadata(
                    "threshold".to_string(),
                    serde_json::Value::Number(
                        config.alert_thresholds.max_vulnerabilities_threshold.into(),
                    ),
                )
                .with_risk_level(RiskLevel::High),
            )
            .await;
        }
    }

    /// Get scan status
    pub async fn get_scan_status(&self, scan_id: Uuid) -> Option<ScanStatus> {
        self.active_scans.lock().await.get(&scan_id).cloned()
    }

    /// Get scan result
    pub async fn get_scan_result(&self, scan_id: Uuid) -> Option<ScanResult> {
        self.scan_results
            .read()
            .await
            .iter()
            .find(|r| r.scan_id == scan_id)
            .cloned()
    }

    /// Get all scan results
    pub async fn get_all_scan_results(&self) -> Vec<ScanResult> {
        self.scan_results.read().await.clone()
    }

    /// Get recent scan results
    pub async fn get_recent_scan_results(&self, limit: usize) -> Vec<ScanResult> {
        let mut results = self.scan_results.read().await.clone();
        results.sort_by(|a, b| b.start_time.cmp(&a.start_time));
        results.into_iter().take(limit).collect()
    }

    /// Get scan results by scanner type
    pub async fn get_scan_results_by_type(&self, scanner_type: ScannerType) -> Vec<ScanResult> {
        self.scan_results
            .read()
            .await
            .iter()
            .filter(|r| r.scanner_type == scanner_type)
            .cloned()
            .collect()
    }

    /// Get vulnerability summary
    pub async fn get_vulnerability_summary(&self) -> VulnerabilitySummary {
        let results = self.scan_results.read().await;
        let total_scans = results.len();

        let mut total_vulnerabilities = 0;
        let mut vulnerabilities_by_severity = HashMap::new();
        let mut scanners_used = std::collections::HashSet::new();

        for result in results.iter() {
            total_vulnerabilities += result.findings.len();
            scanners_used.insert(result.scanner_type.clone());

            for finding in &result.findings {
                *vulnerabilities_by_severity
                    .entry(finding.severity.clone())
                    .or_insert(0) += 1;
            }
        }

        VulnerabilitySummary {
            total_scans,
            total_vulnerabilities,
            vulnerabilities_by_severity,
            active_scanners: scanners_used.len(),
            last_scan_time: results.iter().map(|r| r.start_time).max(),
        }
    }

    /// Start scheduled scanning (simplified for demonstration)
    pub async fn start_scheduled_scanning(&self) -> Result<(), ScannerError> {
        if !self.config.enabled {
            return Ok(());
        }

        info!("Starting scheduled vulnerability scanning");

        let configs = self.scan_configs.read().await.clone();

        for (scanner_type, config) in configs {
            if config.enabled && config.frequency_minutes > 0 {
                info!(
                    "Scheduled scanning configured for {:?} every {} minutes",
                    scanner_type, config.frequency_minutes
                );
                // In a real implementation, this would spawn background tasks
                // For demonstration, we just log the configuration
            }
        }

        Ok(())
    }

    /// Cleanup old scan results
    pub async fn cleanup_old_results(&self) {
        let retention_period =
            Duration::from_secs(self.config.result_retention_days as u64 * 24 * 60 * 60);
        let cutoff_time =
            Utc::now() - chrono::Duration::from_std(retention_period).unwrap_or_default();

        let mut results = self.scan_results.write().await;
        results.retain(|r| r.start_time > cutoff_time);

        info!(
            "Cleaned up old vulnerability scan results, {} results retained",
            results.len()
        );
    }

    /// Get available scanners
    pub fn get_available_scanners(&self) -> Vec<ScannerType> {
        self.available_scanners
            .iter()
            .filter(|(_, available)| **available)
            .map(|(scanner_type, _)| scanner_type.clone())
            .collect()
    }

    /// Get scanner configuration schema
    pub fn get_scanner_config_schema(
        &self,
        scanner_type: &ScannerType,
    ) -> Option<serde_json::Value> {
        // Return basic schema for demonstration
        match scanner_type {
            ScannerType::NetworkVulnerabilityScanner => Some(serde_json::json!({
                "type": "object",
                "properties": {
                    "nmap_path": {"type": "string"},
                    "timing_template": {"type": "string", "enum": ["T0", "T1", "T2", "T3", "T4", "T5"]}
                }
            })),
            ScannerType::DependencyScanner => Some(serde_json::json!({
                "type": "object",
                "properties": {
                    "cargo_audit_path": {"type": "string"}
                }
            })),
            _ => None,
        }
    }
}

/// Vulnerability summary statistics
#[derive(Debug, Serialize, Deserialize)]
pub struct VulnerabilitySummary {
    pub total_scans: usize,
    pub total_vulnerabilities: usize,
    pub vulnerabilities_by_severity: HashMap<VulnerabilitySeverity, usize>,
    pub active_scanners: usize,
    pub last_scan_time: Option<DateTime<Utc>>,
}

/// Helper trait for ScannerType
impl AsRef<str> for ScannerType {
    fn as_ref(&self) -> &str {
        match self {
            ScannerType::NetworkVulnerabilityScanner => "network_vulnerability_scanner",
            ScannerType::ContainerImageScanner => "container_image_scanner",
            ScannerType::DependencyScanner => "dependency_scanner",
            ScannerType::ConfigurationScanner => "configuration_scanner",
            ScannerType::WebApplicationScanner => "web_application_scanner",
            ScannerType::CustomScanner(name) => name,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_vulnerability_finding_creation() {
        let finding = VulnerabilityFinding::new(
            "Test Vulnerability".to_string(),
            "Test description".to_string(),
            VulnerabilitySeverity::High,
            "Test Component".to_string(),
        );

        assert_eq!(finding.title, "Test Vulnerability");
        assert_eq!(finding.severity, VulnerabilitySeverity::High);
        assert!(!finding.acknowledged);
        assert!(!finding.resolved);
    }

    #[tokio::test]
    async fn test_vulnerability_scanner_manager() {
        let config = VulnerabilityScannerConfig::default();
        let manager = VulnerabilityScannerManager::new(config);

        let available_scanners = manager.get_available_scanners();
        assert!(!available_scanners.is_empty());
    }

    #[tokio::test]
    async fn test_scan_config_validation() {
        let config = ScanConfig::default();
        assert_eq!(
            config.scanner_type,
            ScannerType::NetworkVulnerabilityScanner
        );
        assert!(!config.enabled);
    }
}
